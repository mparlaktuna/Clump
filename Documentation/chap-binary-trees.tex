\chapter{Binary trees}
\label{chap-binary-trees}

\section{Classes}

\Defclass {node}

This class is the base class for all node types in binary trees.

\Defclass {simple-node}

This class is a subclass of the class \texttt{node}.  It does not add
any slots, and is only meant for client code to be able to distinguish
between a node with a parent and a node without one.

\Defclass {node-with-parent}

This class is a subclass of the class \texttt{node}.  It adds a slot
for storing a reference to the parent node in a binary tree.

\section{Basic operations}

\Defgeneric {left} {node}

Given a node, return the left child of that node.  The value returned
by this function may be either an instance of (a subclass of) the
class \texttt{node} or \texttt{nil} if the left child of \textit{node}
is the empty tree.

\Defgeneric {(setf left)} {new-left node}

Given a tree \texttt{new-left} and a node \texttt{node}, set the left
child of \texttt{node} to \texttt{new-left}.  The argument
\texttt{new-left} can be either a node or \texttt{nil}.

An \texttt{:after} method is provided with both parameters specialized
to\\ \texttt{node-with-parent}.  This method calls \texttt{(setf
  parent)} with \texttt{node} and \texttt{new-left} as arguments.

\Defgeneric {right} {node}

Given a node, return the right child of that node.  The value returned
by this function may be either an instance of (a subclass of) the
class \texttt{node} or \texttt{nil} if the right child of
\textit{node} is the empty tree.

\Defgeneric {(setf right)} {new-right node}

Given a tree \texttt{new-right} and a node \texttt{node}, set the
right child of \texttt{node} to \texttt{new-right}.  The argument
\texttt{new-right} can be either a node or \texttt{nil}.

An \texttt{:after} method is provided with both parameters specialized
to\\ \texttt{node-with-parent}.  This method calls \texttt{(setf
  parent)} with \texttt{node} and \texttt{new-right} as arguments.

\section{Traversal}

\sysname{} contains two generic functions for traversing binary trees,
both with the same signature and the same result.

\Defgeneric {recursive-traversal} {tree pre in post}

\Defgeneric {iterative-traversal} {tree pre in post}

\section{Rotation}
\label{sec-rotation}

Rotation is a fundamental operation on nodes of a binary tree.  It is
used in a variety of special cases of binary trees, in particular in
\emph{AVL trees} \cite{Adelson-Velskii_Landis_1962}, \emph{red-black
  trees} \cite{Guibas:1978:DFB:1382432.1382565}, and \emph{splay
  trees} \cite{Sleator:1985:SBS:3828.3835}.

Rotation is important because, although it changes the structure of
the tree, it \emph{preserves the in-order depth-first traversal}.
Since this order is what defines the contents of the tree when it is
used either as a \emph{dictionary} or to represent a \emph{sequence},
rotation can be applied without changing the meaning of what it
contains.

Rotation is illustrated in \refFig{fig-rotation}.

\begin{figure}
\begin{center}
\inputfig{fig-rotation.pdf_t}
\end{center}
\caption{\label{fig-rotation}
Rotation.}
\end{figure}

Two symmetrical operations are provided, namely \emph{left rotation}
and \emph{right rotation}.  In \refFig{fig-rotation}, a left rotation
transforms the tree in the right-hand side of the figure to the tree
in the left-hand side of the figure.  Conversely, a right rotation
transforms the tree in the left-hand side of the figure to the tree
in the right-hand side of the figure.

\section{Splaying}
\label{sec-splaying}

Splaying is fundamental operation of \emph{splay trees}
\cite{Sleator:1985:SBS:3828.3835}.  It is defined in terms of
rotations \refSec{sec-rotation}.

\begin{figure}
\begin{center}
\inputfig{fig-splay-zig-1.pdf_t}
\end{center}
\caption{\label{fig-splay-zig-1}
Splaying with a zig step, case 1.}
\end{figure}

\Defgeneric {splay} {node}

This function takes an instance of (a subclass of)
\texttt{node-with-parent} and splays it so that it becomes the root of
the entire tree.  The function \texttt{splay} returns its argument
\texttt{node}.

\Defmethod {splay} {(node \texttt{node-with-parent})}

This method repeatedly invokes the generic function
\texttt{splay-step} passing \texttt{node} as an argument until
\texttt{node} is the root of the entire tree, which is determined by
the fact that its parent is \texttt{nil}.

Client code may define methods on \texttt{splay}, specialized to
strict subclasses of \texttt{node-with-parents}.

\Defgeneric {splay-step} {node}

\Defmethod {splay-step} {(node \texttt{node-with-parent})}

This method calls \texttt{splay-step-with-parent}, passing it
\texttt{node} and the parent of \texttt{node} as arguments.

\Defgeneric {splay-step-with-parent} {node parent}

\Defmethod {splay-step-with-parent}
{(node \texttt{node-with-parent}) (parent \texttt{null})}

This method does nothing and returns \texttt{node}.

\Defmethod {splay-step-with-parent}\\
{(node \texttt{node-with-parent}) (parent \texttt{node-with-parent})}

This method checks whether \texttt{node} is the left or the right child
of \texttt{parent}.  If \texttt{node} is the left child of
\texttt{parent}, it calls \texttt{splay-step-with-right-parent},
passing it \texttt{node} and \texttt{parent} as arguments.  If
\texttt{node} is the right child of \texttt{parent}, it calls
\texttt{splay-step-with-left-parent}, passing it \texttt{node} and
\texttt{parent} as arguments.

\Defgeneric {splay-step-with-right-parent} {node parent}

\Defmethod {splay-step-with-right-parent}\\
{(node \texttt{node-with-parent}) (parent \texttt{node-with-parent})}

This method calls \texttt{splay-step-with-right-parent-and-grandparent},
passing it \texttt{node}, \texttt{parent} and the parent of
\texttt{parent} as arguments.

\Defgeneric {splay-step-with-left-parent} {node parent}

\Defmethod {splay-step-with-left-parent}\\
{(node \texttt{node-with-parent}) (parent \texttt{node-with-parent})}

This method calls \texttt{splay-step-with-left-parent-and-grandparent},
passing it \texttt{node}, \texttt{parent} and the parent of
\texttt{parent} as arguments.
